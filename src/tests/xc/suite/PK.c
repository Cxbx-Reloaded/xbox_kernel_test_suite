#include <xboxkrnl/xboxkrnl.h>
#include <string.h>

#include "util/output.h"
#include "assertions/defines.h"
#include "assertions/xc.h"

// Public xbox habibi key (taken from xbedump of XQEMU)
unsigned char pub_key[] = {
	0x52,0x53,0x41,0x31, 0x08,0x01,0x00,0x00, 0x00,0x08,0x00,0x00, 0xff,0x00,0x00,0x00,
	0x01,0x00,0x01,0x00,
	// Public Modulus "m"
	0xd3,0xd7,0x4e,0xe5, 0x66,0x3d,0xd7,0xe6, 0xc2,0xd4,0xa3,0xa1, 0xf2,0x17,0x36,0xd4,
	0x2e,0x52,0xf6,0xd2, 0x02,0x10,0xf5,0x64, 0x9c,0x34,0x7b,0xff, 0xef,0x7f,0xc2,0xee,
	0xbd,0x05,0x8b,0xde, 0x79,0xb4,0x77,0x8e, 0x5b,0x8c,0x14,0x99, 0xe3,0xae,0xc6,0x73,
	0x72,0x73,0xb5,0xfb, 0x01,0x5b,0x58,0x46, 0x6d,0xfc,0x8a,0xd6, 0x95,0xda,0xed,0x1b,
	0x2e,0x2f,0xa2,0x29, 0xe1,0x3f,0xf1,0xb9, 0x5b,0x64,0x51,0x2e, 0xa2,0xc0,0xf7,0xba,
	0xb3,0x3e,0x8a,0x75, 0xff,0x06,0x92,0x5c, 0x07,0x26,0x75,0x79, 0x10,0x5d,0x47,0xbe,
	0xd1,0x6a,0x52,0x90, 0x0b,0xae,0x6a,0x0b, 0x33,0x44,0x93,0x5e, 0xf9,0x9d,0xfb,0x15,
	0xd9,0xa4,0x1c,0xcf, 0x6f,0xe4,0x71,0x94, 0xbe,0x13,0x00,0xa8, 0x52,0xca,0x07,0xbd,
	0x27,0x98,0x01,0xa1, 0x9e,0x4f,0xa3,0xed, 0x9f,0xa0,0xaa,0x73, 0xc4,0x71,0xf3,0xe9,
	0x4e,0x72,0x42,0x9c, 0xf0,0x39,0xce,0xbe, 0x03,0x76,0xfa,0x2b, 0x89,0x14,0x9a,0x81,
	0x16,0xc1,0x80,0x8c, 0x3e,0x6b,0xaa,0x05, 0xec,0x67,0x5a,0xcf, 0xa5,0x70,0xbd,0x60,
	0x0c,0xe8,0x37,0x9d, 0xeb,0xf4,0x52,0xea, 0x4e,0x60,0x9f,0xe4, 0x69,0xcf,0x52,0xdb,
	0x68,0xf5,0x11,0xcb, 0x57,0x8f,0x9d,0xa1, 0x38,0x0a,0x0c,0x47, 0x1b,0xb4,0x6c,0x5a,
	0x53,0x6e,0x26,0x98, 0xf1,0x88,0xae,0x7c, 0x96,0xbc,0xf6,0xbf, 0xb0,0x47,0x9a,0x8d,
	0xe4,0xb3,0xe2,0x98, 0x85,0x61,0xb1,0xca, 0x5f,0xf7,0x98,0x51, 0x2d,0x83,0x81,0x76,
	0x0c,0x88,0xba,0xd4, 0xc2,0xd5,0x3c,0x14, 0xc7,0x72,0xda,0x7e, 0x6b,0x90,0x9c,0x89,
	// The remaining bytes of the modulus buffer
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00
};

// Private xbox habibi key (taken from xbedump of XQEMU)
unsigned char prv_key[] = {
	0x52,0x53,0x41,0x32, 0x08,0x01,0x00,0x00, 0x00,0x08,0x00,0x00, 0xff,0x00,0x00,0x00,
	0x01,0x00,0x01,0x00,
	// Public Modulus "m"
	0xd3,0xd7,0x4e,0xe5, 0x66,0x3d,0xd7,0xe6, 0xc2,0xd4,0xa3,0xa1, 0xf2,0x17,0x36,0xd4,
	0x2e,0x52,0xf6,0xd2, 0x02,0x10,0xf5,0x64, 0x9c,0x34,0x7b,0xff, 0xef,0x7f,0xc2,0xee,
	0xbd,0x05,0x8b,0xde, 0x79,0xb4,0x77,0x8e, 0x5b,0x8c,0x14,0x99, 0xe3,0xae,0xc6,0x73,
	0x72,0x73,0xb5,0xfb, 0x01,0x5b,0x58,0x46, 0x6d,0xfc,0x8a,0xd6, 0x95,0xda,0xed,0x1b,
	0x2e,0x2f,0xa2,0x29, 0xe1,0x3f,0xf1,0xb9, 0x5b,0x64,0x51,0x2e, 0xa2,0xc0,0xf7,0xba,
	0xb3,0x3e,0x8a,0x75, 0xff,0x06,0x92,0x5c, 0x07,0x26,0x75,0x79, 0x10,0x5d,0x47,0xbe,
	0xd1,0x6a,0x52,0x90, 0x0b,0xae,0x6a,0x0b, 0x33,0x44,0x93,0x5e, 0xf9,0x9d,0xfb,0x15,
	0xd9,0xa4,0x1c,0xcf, 0x6f,0xe4,0x71,0x94, 0xbe,0x13,0x00,0xa8, 0x52,0xca,0x07,0xbd,
	0x27,0x98,0x01,0xa1, 0x9e,0x4f,0xa3,0xed, 0x9f,0xa0,0xaa,0x73, 0xc4,0x71,0xf3,0xe9,
	0x4e,0x72,0x42,0x9c, 0xf0,0x39,0xce,0xbe, 0x03,0x76,0xfa,0x2b, 0x89,0x14,0x9a,0x81,
	0x16,0xc1,0x80,0x8c, 0x3e,0x6b,0xaa,0x05, 0xec,0x67,0x5a,0xcf, 0xa5,0x70,0xbd,0x60,
	0x0c,0xe8,0x37,0x9d, 0xeb,0xf4,0x52,0xea, 0x4e,0x60,0x9f,0xe4, 0x69,0xcf,0x52,0xdb,
	0x68,0xf5,0x11,0xcb, 0x57,0x8f,0x9d,0xa1, 0x38,0x0a,0x0c,0x47, 0x1b,0xb4,0x6c,0x5a,
	0x53,0x6e,0x26,0x98, 0xf1,0x88,0xae,0x7c, 0x96,0xbc,0xf6,0xbf, 0xb0,0x47,0x9a,0x8d,
	0xe4,0xb3,0xe2,0x98, 0x85,0x61,0xb1,0xca, 0x5f,0xf7,0x98,0x51, 0x2d,0x83,0x81,0x76,
	0x0c,0x88,0xba,0xd4, 0xc2,0xd5,0x3c,0x14, 0xc7,0x72,0xda,0x7e, 0x6b,0x90,0x9c,0x89,
	// The remaining bytes of the modulus buffer
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	// Private exponent "d"
	0x61,0x52,0xaa,0xfe, 0x1f,0xa5,0x77,0x0b, 0x8d,0x9b,0x10,0x83, 0x68,0x67,0xe6,0x34,
	0x58,0x0d,0x70,0x5a, 0x49,0x58,0x97,0xcd, 0x1d,0xe0,0x21,0x6b, 0xd7,0xea,0x2e,0xaa,
	0x0e,0xc8,0x67,0xc1, 0x23,0xdc,0xe8,0xab, 0xc7,0x6b,0x79,0xff, 0x3e,0xbb,0xee,0x27,
	0x2c,0x2e,0x30,0x9f, 0xcb,0x1e,0x0b,0xd6, 0xbb,0x8b,0x03,0x0b, 0x7b,0x2d,0x81,0xd0,
	0x06,0xa2,0xb5,0xf1, 0x4a,0x91,0x11,0xee, 0x4a,0x86,0xf3,0x96, 0x88,0x2e,0x0f,0xd4,
	0xe9,0xd2,0x88,0xae, 0x1b,0x7b,0x0a,0xdd, 0x42,0xbc,0x08,0x17, 0x3e,0x1c,0xb4,0xf4,
	0xbf,0x99,0xfe,0x4b, 0xdc,0x76,0x4a,0x6b, 0x83,0x6d,0x17,0x83, 0x27,0x12,0xce,0x3a,
	0x88,0x43,0xcc,0xd7, 0x13,0x77,0x3f,0x13, 0x49,0x33,0x78,0x82, 0x1b,0x41,0x2f,0xaa,
	0xfb,0xba,0xfb,0x19, 0x76,0xe4,0x58,0xfb, 0x0c,0x62,0xb0,0x53, 0xfe,0xac,0x24,0x16,
	0x30,0x46,0xdd,0x5f, 0xce,0xef,0x38,0x70, 0x3e,0x7b,0x73,0x0f, 0xec,0x43,0x1c,0x43,
	0x3e,0x6a,0x09,0x85, 0x2e,0xc0,0xff,0x01, 0x4f,0x5b,0x87,0xc0, 0xbe,0xb3,0xbc,0xc3,
	0xdd,0x07,0xb7,0x29, 0x26,0x1b,0xd9,0x7e, 0x97,0xc1,0x9c,0x6a, 0xd4,0x34,0x3c,0x18,
	0xe1,0xad,0x24,0xd8, 0xbd,0x00,0xf0,0x49, 0xbb,0x63,0xa7,0xf0, 0xb7,0x1a,0x6f,0x20,
	0x26,0x0f,0x76,0xf4, 0xa0,0x66,0xad,0x00, 0x3e,0xe4,0x8d,0xe8, 0x05,0x6e,0xeb,0x8f,
	0x12,0x88,0xd8,0x5b, 0xcd,0x72,0xdd,0xec, 0xd8,0x70,0x11,0x23, 0x7d,0xec,0x5c,0xa7,
	0x95,0xea,0xdd,0x4b, 0xdf,0xf3,0x76,0x1f, 0x41,0x43,0xbf,0x2c, 0x44,0x08,0x1c,0x28
};

// The string "Encrypt me" encrypted by XcPKEncPublic with pub_key
unsigned char encrypted_string[] = {
	0xdc,0x25,0xdc,0xc5, 0x23,0xb6,0x5c,0x46, 0x0d,0xb8,0x6c,0xbd,
	0xe3,0x80,0x28,0x3f, 0x42,0xdf,0x42,0xab, 0x7f,0x22,0xd7,0x3e,
	0xb3,0x81,0xde,0xd7, 0x3e,0xe4,0x1a,0x2e, 0xee,0xe7,0xd8,0x2f,
	0xbd,0xdc,0x44,0x4d, 0x55,0x19,0x32,0xbb, 0xee,0xf0,0x45,0x49,
	0x13,0x09,0x46,0x37, 0x07,0x16,0xdf,0x8f, 0x77,0x28,0x88,0x44,
	0x04,0x6a,0x26,0x9b, 0x0d,0x47,0x04,0x85, 0x40,0x84,0x4c,0x03,
	0xba,0x75,0xe3,0x65, 0xb7,0x0a,0xa1,0x10, 0x8b,0xa0,0x2c,0xff,
	0xa0,0xa2,0x9b,0xf0, 0xbd,0x85,0x36,0xbd, 0x75,0x4c,0xec,0x96,
	0xe1,0x7c,0x26,0xc6, 0x63,0xcb,0x49,0x27, 0xf4,0x58,0xf4,0x48,
	0xe5,0x02,0x62,0x36, 0x10,0x24,0xc2,0x59, 0x7b,0x47,0x9e,0x7d,
	0x6d,0xcc,0x57,0xdd, 0x83,0x9b,0xd2,0x95, 0x5c,0xf8,0x56,0x2f,
	0x3c,0xe3,0x72,0x92, 0x59,0x15,0x99,0x65, 0x73,0xdd,0x6b,0x4c,
	0x4f,0x7c,0x49,0x71, 0xbd,0xed,0x8f,0x36, 0xe9,0x5f,0x3d,0xf9,
	0x10,0x2b,0xb9,0x56, 0xbe,0xc3,0xfa,0xdc, 0x86,0x54,0x0d,0x84,
	0x0d,0xd4,0xaf,0xe7, 0x02,0xeb,0x93,0x3e, 0xef,0x95,0x16,0x6c,
	0xf0,0xad,0x21,0x7c, 0x92,0x49,0x3f,0x24, 0x4c,0xf2,0xce,0x05,
	0xc7,0xe8,0xb9,0x65, 0x80,0xe9,0x3f,0x0a, 0xc2,0x82,0xee,0x41,
	0x92,0x95,0x46,0x1e, 0x7b,0xd7,0xea,0xd8, 0x00,0x72,0x11,0x9a,
	0xe4,0x5b,0xeb,0xb5, 0xcb,0x88,0x04,0x46, 0x0d,0xf1,0xcc,0xf5,
	0x2b,0x45,0x95,0x5e, 0x54,0x1d,0x7f,0x0f, 0xce,0x34,0x07,0x40,
	0xb9,0x5d,0x8e,0x42, 0x45,0x7d,0x5a,0xec, 0xcb,0x83,0xca,0xe9,
	0x67,0x0d,0x7a,0x7b, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00
};

void test_XcPKEncPublic(int func_num, const char* func_name)
{
	BOOL test_passed = 1;
	ULONG ret = 0;
	UCHAR input_buffer[264]          = { 0 };
	UCHAR output_buffer[264]         = { 0 };
	UCHAR original_magic_string[]    = { 0x52,0x53,0x41,0x31 };
	UCHAR original_key_bit_size[]    = { 0x00,0x08,0x00,0x00 };
	UCHAR original_max_encode_size[] = { 0xff,0x00,0x00,0x00 };
	UCHAR key_bit_size1024[]         = { 0x00,0x04,0x00,0x00 };
	UCHAR bogus_data[]               = { 0xcc,0xcc,0xcc,0xcc };

	print_test_header(func_num, func_name);
	
	// Correct usage
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10); // "Encrypt me"
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	if(ret == 1) {
		test_passed &= assert_hashed_result(output_buffer,
		                                    sizeof(output_buffer),
		                                    (PUCHAR)"\x1a\x31\x40\xee\x8e\x0b\x07\xff\x36\xe3\xb1\x8e\xc8\x87\xe2\xd7\xb1\x63\x01\xe4",
		                                    "2048 key bit");
	}
	else {
		test_passed &= 0;
	}

	// Wrong magic string
	memcpy(pub_key, bogus_data, 4);
	memset(input_buffer, 0, 264);
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10);
	memset(output_buffer, 0, 264);
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	memset(input_buffer, 0, 264);
	if(ret == 0 && memcmp(output_buffer, input_buffer, 264) == 0) {
		test_passed &= 1;
	}
	else {
		test_passed &= 0;
	}
	
	// Using bogus_data as modulus buffer size freezes (crash?) my xbox so I won't test it
	
	// 1024 key bit size but using bogus_data as key bit size freezes (crash?) my xbox so I won't test it
	memcpy(pub_key, original_magic_string, 4);
	memcpy(&pub_key[8], key_bit_size1024, 4);
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10);
	memset(output_buffer, 0, 264);
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	if(ret == 1) {
		test_passed &= assert_hashed_result(output_buffer,
		                                    sizeof(output_buffer),
		                                    (PUCHAR)"\x0c\xd6\x8f\x80\xc2\x04\xca\x68\x0b\x9d\x21\x37\x1c\xcb\x46\x32\x68\xb2\x8a\x92",
		                                    "1024 key bit");
	}
	else {
		test_passed &= 0;
	}
	
	// Wrong max encode size -> same result as if original value
	memcpy(&pub_key[8], original_key_bit_size, 4);
	memcpy(&pub_key[12], bogus_data, 4);
	memset(input_buffer, 0, 264);
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10);
	memset(output_buffer, 0, 264);
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	if(ret == 1) {
		test_passed &= assert_hashed_result(output_buffer,
		                                    sizeof(output_buffer),
		                                    (PUCHAR)"\x1a\x31\x40\xee\x8e\x0b\x07\xff\x36\xe3\xb1\x8e\xc8\x87\xe2\xd7\xb1\x63\x01\xe4",
		                                    "wrong max encode size");
	}
	else {
		test_passed &= 0;
	}
	memcpy(&pub_key[12], original_max_encode_size, 4);
	
	print_test_footer(func_num, func_name, test_passed);
}

void test_XcPKDecPrivate(int func_num, const char* func_name)
{
	BOOL test_passed = 1;
	ULONG ret = 0;
	UCHAR input_buffer[264]          = { 0 };
	UCHAR output_buffer[264]         = { 0 };
	UCHAR original_magic_string[]    = { 0x52,0x53,0x41,0x32 };
	UCHAR bogus_data[]               = { 0xcc,0xcc,0xcc,0xcc };
	
	print_test_header(func_num, func_name);
	
	// Correct usage
	// While this succeeds on real hardware, it still fails to give back the original "Encrypt me" string. I believe it's because the
	// prv_key is missing the parameters of the Chinese Remainder Theorem to perform the decryption correctly, but now I'm too lazy
	// to calculate them...
	memcpy(input_buffer, encrypted_string, sizeof(encrypted_string));
	ret = XcPKDecPrivate(prv_key, input_buffer, output_buffer);
	if(ret == 1) {
		test_passed &= 1;
	}
	else {
		test_passed &= 0;
	}
	
	// Wrong magic string
	memcpy(prv_key, bogus_data, 4);
	memset(input_buffer, 0, 264);
	memcpy(input_buffer, encrypted_string, sizeof(encrypted_string));
	memset(output_buffer, 0, 264);
	ret = XcPKDecPrivate(prv_key, input_buffer, output_buffer);
	memset(input_buffer, 0, 264);
	if(ret == 0 && memcmp(output_buffer, input_buffer, 264) == 0) {
		test_passed &= 1;
	}
	else {
		test_passed &= 0;
	}
	memcpy(prv_key, original_magic_string, 4);
	
	print_test_footer(func_num, func_name, test_passed);
}

void test_XcPKGetKeyLen(int func_num, const char* func_name)
{
	BOOL test_passed = 1;
	ULONG ret = 0;
	UCHAR original_key_size[] = { 0x08,0x01,0x00,0x00 };
	UCHAR bogus_data[]        = { 0xcc,0xcc,0xcc,0xcc };

	print_test_header(func_num, func_name);
	
	// Public key
	ret = XcPKGetKeyLen(pub_key);
	GEN_CHECK(ret, 0x108, "pub_key_len")
	
	// Wrong key lenght
	memcpy(&pub_key[4], bogus_data, 4);
	ret = XcPKGetKeyLen(pub_key);
	GEN_CHECK(ret, 0xCCCCCCCC, "pub_key_len (bad)")
	
	// Private key
	memcpy(&pub_key[4], original_key_size, 4);
	ret = XcPKGetKeyLen(prv_key);
	GEN_CHECK(ret, 0x108, "prv_key_len")
	
	print_test_footer(func_num, func_name, test_passed);
}

void test_XcVerifyPKCS1Signature(int func_num, const char* func_name)
{
	BOOL test_passed = 1;
	ULONG ret = 0;
	UCHAR digest[]     = { 0xd2,0x98,0x3c,0x52,0x96,0x43,0x95,0x2f,0xf9,0x5b,0x9a,0xc3,0x67,0x4c,0xb4,0x3a,0xfb,0x3d,0x3d,0x69 };
	UCHAR digest_inv[] = { 0x69,0x3d,0x3d,0xfb,0x3a,0xb4,0x4c,0x67,0xc3,0x9a,0x5b,0xf9,0x2f,0x95,0x43,0x96,0x52,0x3c,0x98,0xd2 };
	UCHAR signature[]  = {
	    0x9c,0x64,0x3f,0xf1,0x56,0x89,0xd7,0x26,0xbb,0xf7,0x42,0xf2,0x37,0x31,0x0f,0x23,0x77,0x91,0x5e,0x2d,0xe7,0x6d,0x56,0xcf,0x87,0x30,
	    0x97,0x1f,0x82,0xc9,0xe3,0x0d,0x9e,0xd5,0x25,0xec,0xe1,0xbf,0x27,0x5c,0x04,0x3d,0xc4,0xf8,0x42,0x3c,0x76,0xaa,0x34,0xa3,0xd2,0x01,
	    0x76,0xaa,0xdf,0x9a,0x32,0x33,0xb6,0xed,0x7f,0xc5,0x32,0xb4,0x1f,0x22,0x46,0x09,0x50,0xb2,0xb2,0xc7,0x0b,0xb4,0xd9,0x2c,0x08,0x7b,
	    0x2a,0x62,0x5b,0x42,0xad,0x04,0xad,0xac,0xa2,0x9b,0xed,0xbb,0x6b,0xe4,0xda,0xb9,0xb7,0x12,0x7f,0xc0,0x7c,0x61,0x6c,0x89,0x21,0x9c,
	    0x14,0x1a,0x66,0xcd,0x41,0x1f,0xad,0x95,0xcb,0xc5,0x3b,0x54,0x3e,0x6a,0x54,0x19,0x88,0x4d,0x5e,0x57,0x1f,0x33,0x61,0xd6,0x63,0xef,
	    0xaa,0x59,0x53,0xce,0xfc,0x48,0xc1,0x6b,0x5b,0x4e,0x77,0x95,0x20,0x53,0x4a,0x0d,0x84,0xd1,0x40,0x41,0x41,0x27,0x40,0xee,0x12,0x4b,
	    0x5d,0x55,0xb2,0xbf,0x47,0xce,0x88,0x8d,0xb0,0xde,0x53,0x79,0x25,0xa3,0x59,0xae,0xd8,0xca,0x63,0x9a,0x51,0x66,0x32,0xb8,0x6f,0x65,
	    0xac,0xe3,0x81,0x15,0x6a,0xd8,0xa8,0xdf,0x44,0x47,0xfc,0x31,0x55,0xf9,0x92,0x27,0x85,0x7d,0x0c,0xd1,0xb6,0x25,0xcd,0x72,0xcd,0xb5,
	    0x94,0xd5,0x25,0x92,0xc4,0x1d,0x23,0x03,0x58,0x28,0xc0,0xab,0x7f,0x3b,0xd0,0x40,0x4d,0x1f,0x89,0x98,0x40,0xd8,0x23,0x40,0x6d,0xdd,
	    0xc7,0x61,0xbc,0x6a,0xbb,0x56,0x91,0x2e,0x47,0xd1,0x3b,0x97,0xed,0xa7,0x91,0xb7,0x87,0x70,0x30,0x6f,0xdc,0x30
	};
	
	print_test_header(func_num, func_name);
	
	ret = XcVerifyPKCS1Signature(signature, XePublicKeyData, digest);
	if(ret == 1) {
	    test_passed &= 1;
	}
	else {
	    test_passed &= 0;
	}
	
	ret = XcVerifyPKCS1Signature(signature, XePublicKeyData, digest_inv);
	if(ret == 0) {
	    test_passed &= 1;
	}
	else {
	    test_passed &= 0;
	}

	print_test_footer(func_num, func_name, test_passed);
}

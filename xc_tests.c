#include <hal/fileio.h>
#include <string.h>

#include "global.h"
#include "output.h"


// Public xbox habibi key (taken from xbedump of XQEMU)
unsigned char pub_key[] = {
    0x52,0x53,0x41,0x31, 0x08,0x01,0x00,0x00, 0x00,0x08,0x00,0x00, 0xff,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,
    // Public Modulus "m"
    0xd3,0xd7,0x4e,0xe5, 0x66,0x3d,0xd7,0xe6, 0xc2,0xd4,0xa3,0xa1, 0xf2,0x17,0x36,0xd4,
    0x2e,0x52,0xf6,0xd2, 0x02,0x10,0xf5,0x64, 0x9c,0x34,0x7b,0xff, 0xef,0x7f,0xc2,0xee,
    0xbd,0x05,0x8b,0xde, 0x79,0xb4,0x77,0x8e, 0x5b,0x8c,0x14,0x99, 0xe3,0xae,0xc6,0x73,
    0x72,0x73,0xb5,0xfb, 0x01,0x5b,0x58,0x46, 0x6d,0xfc,0x8a,0xd6, 0x95,0xda,0xed,0x1b,
    0x2e,0x2f,0xa2,0x29, 0xe1,0x3f,0xf1,0xb9, 0x5b,0x64,0x51,0x2e, 0xa2,0xc0,0xf7,0xba,
    0xb3,0x3e,0x8a,0x75, 0xff,0x06,0x92,0x5c, 0x07,0x26,0x75,0x79, 0x10,0x5d,0x47,0xbe,
    0xd1,0x6a,0x52,0x90, 0x0b,0xae,0x6a,0x0b, 0x33,0x44,0x93,0x5e, 0xf9,0x9d,0xfb,0x15,
    0xd9,0xa4,0x1c,0xcf, 0x6f,0xe4,0x71,0x94, 0xbe,0x13,0x00,0xa8, 0x52,0xca,0x07,0xbd,
    0x27,0x98,0x01,0xa1, 0x9e,0x4f,0xa3,0xed, 0x9f,0xa0,0xaa,0x73, 0xc4,0x71,0xf3,0xe9,
    0x4e,0x72,0x42,0x9c, 0xf0,0x39,0xce,0xbe, 0x03,0x76,0xfa,0x2b, 0x89,0x14,0x9a,0x81,
    0x16,0xc1,0x80,0x8c, 0x3e,0x6b,0xaa,0x05, 0xec,0x67,0x5a,0xcf, 0xa5,0x70,0xbd,0x60,
    0x0c,0xe8,0x37,0x9d, 0xeb,0xf4,0x52,0xea, 0x4e,0x60,0x9f,0xe4, 0x69,0xcf,0x52,0xdb,
    0x68,0xf5,0x11,0xcb, 0x57,0x8f,0x9d,0xa1, 0x38,0x0a,0x0c,0x47, 0x1b,0xb4,0x6c,0x5a,
    0x53,0x6e,0x26,0x98, 0xf1,0x88,0xae,0x7c, 0x96,0xbc,0xf6,0xbf, 0xb0,0x47,0x9a,0x8d,
    0xe4,0xb3,0xe2,0x98, 0x85,0x61,0xb1,0xca, 0x5f,0xf7,0x98,0x51, 0x2d,0x83,0x81,0x76,
    0x0c,0x88,0xba,0xd4, 0xc2,0xd5,0x3c,0x14, 0xc7,0x72,0xda,0x7e, 0x6b,0x90,0x9c,0x89,
	// The remaining bytes of the modulus buffer
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00
};

// Private xbox habibi key (taken from xbedump of XQEMU)
unsigned char prv_key[] = {
	0x52,0x53,0x41,0x32, 0x08,0x01,0x00,0x00, 0x00,0x08,0x00,0x00, 0xff,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,
    // Public Modulus "m"
    0xd3,0xd7,0x4e,0xe5, 0x66,0x3d,0xd7,0xe6, 0xc2,0xd4,0xa3,0xa1, 0xf2,0x17,0x36,0xd4,
    0x2e,0x52,0xf6,0xd2, 0x02,0x10,0xf5,0x64, 0x9c,0x34,0x7b,0xff, 0xef,0x7f,0xc2,0xee,
    0xbd,0x05,0x8b,0xde, 0x79,0xb4,0x77,0x8e, 0x5b,0x8c,0x14,0x99, 0xe3,0xae,0xc6,0x73,
    0x72,0x73,0xb5,0xfb, 0x01,0x5b,0x58,0x46, 0x6d,0xfc,0x8a,0xd6, 0x95,0xda,0xed,0x1b,
    0x2e,0x2f,0xa2,0x29, 0xe1,0x3f,0xf1,0xb9, 0x5b,0x64,0x51,0x2e, 0xa2,0xc0,0xf7,0xba,
    0xb3,0x3e,0x8a,0x75, 0xff,0x06,0x92,0x5c, 0x07,0x26,0x75,0x79, 0x10,0x5d,0x47,0xbe,
    0xd1,0x6a,0x52,0x90, 0x0b,0xae,0x6a,0x0b, 0x33,0x44,0x93,0x5e, 0xf9,0x9d,0xfb,0x15,
    0xd9,0xa4,0x1c,0xcf, 0x6f,0xe4,0x71,0x94, 0xbe,0x13,0x00,0xa8, 0x52,0xca,0x07,0xbd,
    0x27,0x98,0x01,0xa1, 0x9e,0x4f,0xa3,0xed, 0x9f,0xa0,0xaa,0x73, 0xc4,0x71,0xf3,0xe9,
    0x4e,0x72,0x42,0x9c, 0xf0,0x39,0xce,0xbe, 0x03,0x76,0xfa,0x2b, 0x89,0x14,0x9a,0x81,
    0x16,0xc1,0x80,0x8c, 0x3e,0x6b,0xaa,0x05, 0xec,0x67,0x5a,0xcf, 0xa5,0x70,0xbd,0x60,
    0x0c,0xe8,0x37,0x9d, 0xeb,0xf4,0x52,0xea, 0x4e,0x60,0x9f,0xe4, 0x69,0xcf,0x52,0xdb,
    0x68,0xf5,0x11,0xcb, 0x57,0x8f,0x9d,0xa1, 0x38,0x0a,0x0c,0x47, 0x1b,0xb4,0x6c,0x5a,
    0x53,0x6e,0x26,0x98, 0xf1,0x88,0xae,0x7c, 0x96,0xbc,0xf6,0xbf, 0xb0,0x47,0x9a,0x8d,
    0xe4,0xb3,0xe2,0x98, 0x85,0x61,0xb1,0xca, 0x5f,0xf7,0x98,0x51, 0x2d,0x83,0x81,0x76,
    0x0c,0x88,0xba,0xd4, 0xc2,0xd5,0x3c,0x14, 0xc7,0x72,0xda,0x7e, 0x6b,0x90,0x9c,0x89,
	// The remaining bytes of the modulus buffer
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	// Private exponent "d"
	0x61,0x52,0xaa,0xfe, 0x1f,0xa5,0x77,0x0b, 0x8d,0x9b,0x10,0x83, 0x68,0x67,0xe6,0x34,
    0x58,0x0d,0x70,0x5a, 0x49,0x58,0x97,0xcd, 0x1d,0xe0,0x21,0x6b, 0xd7,0xea,0x2e,0xaa,
    0x0e,0xc8,0x67,0xc1, 0x23,0xdc,0xe8,0xab, 0xc7,0x6b,0x79,0xff, 0x3e,0xbb,0xee,0x27,
    0x2c,0x2e,0x30,0x9f, 0xcb,0x1e,0x0b,0xd6, 0xbb,0x8b,0x03,0x0b, 0x7b,0x2d,0x81,0xd0,
    0x06,0xa2,0xb5,0xf1, 0x4a,0x91,0x11,0xee, 0x4a,0x86,0xf3,0x96, 0x88,0x2e,0x0f,0xd4,
    0xe9,0xd2,0x88,0xae, 0x1b,0x7b,0x0a,0xdd, 0x42,0xbc,0x08,0x17, 0x3e,0x1c,0xb4,0xf4,
    0xbf,0x99,0xfe,0x4b, 0xdc,0x76,0x4a,0x6b, 0x83,0x6d,0x17,0x83, 0x27,0x12,0xce,0x3a,
    0x88,0x43,0xcc,0xd7, 0x13,0x77,0x3f,0x13, 0x49,0x33,0x78,0x82, 0x1b,0x41,0x2f,0xaa,
    0xfb,0xba,0xfb,0x19, 0x76,0xe4,0x58,0xfb, 0x0c,0x62,0xb0,0x53, 0xfe,0xac,0x24,0x16,
    0x30,0x46,0xdd,0x5f, 0xce,0xef,0x38,0x70, 0x3e,0x7b,0x73,0x0f, 0xec,0x43,0x1c,0x43,
    0x3e,0x6a,0x09,0x85, 0x2e,0xc0,0xff,0x01, 0x4f,0x5b,0x87,0xc0, 0xbe,0xb3,0xbc,0xc3,
    0xdd,0x07,0xb7,0x29, 0x26,0x1b,0xd9,0x7e, 0x97,0xc1,0x9c,0x6a, 0xd4,0x34,0x3c,0x18,
    0xe1,0xad,0x24,0xd8, 0xbd,0x00,0xf0,0x49, 0xbb,0x63,0xa7,0xf0, 0xb7,0x1a,0x6f,0x20,
    0x26,0x0f,0x76,0xf4, 0xa0,0x66,0xad,0x00, 0x3e,0xe4,0x8d,0xe8, 0x05,0x6e,0xeb,0x8f,
    0x12,0x88,0xd8,0x5b, 0xcd,0x72,0xdd,0xec, 0xd8,0x70,0x11,0x23, 0x7d,0xec,0x5c,0xa7,
    0x95,0xea,0xdd,0x4b, 0xdf,0xf3,0x76,0x1f, 0x41,0x43,0xbf,0x2c, 0x44,0x08,0x1c,0x28
};

// The string "Encrypt me" encrypted by XcPKEncPublic with pub_key
unsigned char encrypted_string[] = {
	0xdc,0x25,0xdc,0xc5, 0x23,0xb6,0x5c,0x46, 0x0d,0xb8,0x6c,0xbd,
	0xe3,0x80,0x28,0x3f, 0x42,0xdf,0x42,0xab, 0x7f,0x22,0xd7,0x3e,
	0xb3,0x81,0xde,0xd7, 0x3e,0xe4,0x1a,0x2e, 0xee,0xe7,0xd8,0x2f,
	0xbd,0xdc,0x44,0x4d, 0x55,0x19,0x32,0xbb, 0xee,0xf0,0x45,0x49,
	0x13,0x09,0x46,0x37, 0x07,0x16,0xdf,0x8f, 0x77,0x28,0x88,0x44,
	0x04,0x6a,0x26,0x9b, 0x0d,0x47,0x04,0x85, 0x40,0x84,0x4c,0x03,
	0xba,0x75,0xe3,0x65, 0xb7,0x0a,0xa1,0x10, 0x8b,0xa0,0x2c,0xff,
	0xa0,0xa2,0x9b,0xf0, 0xbd,0x85,0x36,0xbd, 0x75,0x4c,0xec,0x96,
	0xe1,0x7c,0x26,0xc6, 0x63,0xcb,0x49,0x27, 0xf4,0x58,0xf4,0x48,
	0xe5,0x02,0x62,0x36, 0x10,0x24,0xc2,0x59, 0x7b,0x47,0x9e,0x7d,
	0x6d,0xcc,0x57,0xdd, 0x83,0x9b,0xd2,0x95, 0x5c,0xf8,0x56,0x2f,
	0x3c,0xe3,0x72,0x92, 0x59,0x15,0x99,0x65, 0x73,0xdd,0x6b,0x4c,
	0x4f,0x7c,0x49,0x71, 0xbd,0xed,0x8f,0x36, 0xe9,0x5f,0x3d,0xf9,
	0x10,0x2b,0xb9,0x56, 0xbe,0xc3,0xfa,0xdc, 0x86,0x54,0x0d,0x84,
	0x0d,0xd4,0xaf,0xe7, 0x02,0xeb,0x93,0x3e, 0xef,0x95,0x16,0x6c,
	0xf0,0xad,0x21,0x7c, 0x92,0x49,0x3f,0x24, 0x4c,0xf2,0xce,0x05,
	0xc7,0xe8,0xb9,0x65, 0x80,0xe9,0x3f,0x0a, 0xc2,0x82,0xee,0x41,
	0x92,0x95,0x46,0x1e, 0x7b,0xd7,0xea,0xd8, 0x00,0x72,0x11,0x9a,
	0xe4,0x5b,0xeb,0xb5, 0xcb,0x88,0x04,0x46, 0x0d,0xf1,0xcc,0xf5,
	0x2b,0x45,0x95,0x5e, 0x54,0x1d,0x7f,0x0f, 0xce,0x34,0x07,0x40,
	0xb9,0x5d,0x8e,0x42, 0x45,0x7d,0x5a,0xec, 0xcb,0x83,0xca,0xe9,
	0x67,0x0d,0x7a,0x7b, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00
};

int validate_hashed_result(PUCHAR input, size_t len, PUCHAR res) {
	unsigned char sha1_ctx[116] = { 0 };
	unsigned char digest[20]    = { 0 };
	
	XcSHAInit(sha1_ctx);
	XcSHAUpdate(sha1_ctx, input, len);
	XcSHAFinal(sha1_ctx, digest);
	if(memcmp(digest, res, 20) == 0) {
		return 1;
	}
	else {
		return 0;
	}
}

void test_XcSHAInit(){
    /* FIXME: This is a stub! implement this function! */
}

void test_XcSHAUpdate(){
    /* FIXME: This is a stub! implement this function! */
}

void test_XcSHAFinal(){
    /* FIXME: This is a stub! implement this function! */
}

void test_XcRC4Key(){
    /* FIXME: This is a stub! implement this function! */
}

void test_XcRC4Crypt(){
    /* FIXME: This is a stub! implement this function! */
}

void test_XcHMAC(){
    /* FIXME: This is a stub! implement this function! */
}

void test_XcPKEncPublic(){
    const char* func_num = "0x0155";
    const char* func_name = "XcPKEncPublic";
    BOOL tests_passed = 1;
	ULONG ret = 0;
	UCHAR input_buffer[264]          = { 0 };
	UCHAR output_buffer[264]         = { 0 };
	UCHAR original_magic_string[]    = { 0x52,0x53,0x41,0x31 };
	UCHAR original_key_bit_size[]    = { 0x00,0x08,0x00,0x00 };
	UCHAR original_max_encode_size[] = { 0xff,0x00,0x00,0x00 };
	UCHAR key_bit_size1024[]         = { 0x00,0x04,0x00,0x00 };
	UCHAR bogus_data[]               = { 0xcc,0xcc,0xcc,0xcc };
	
	unsigned char digest[20]    = { 0 };

    print_test_header(func_num, func_name);
	
	// Correct usage
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10); // "Encrypt me"
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	if(ret == 1 && validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x1a\x31\x40\xee\x8e\x0b\x07\xff\x36\xe3\xb1\x8e\xc8\x87\xe2\xd7\xb1\x63\x01\xe4")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Wrong magic string
	memcpy(pub_key, bogus_data, 4);
	memset(input_buffer, 0, 264);
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10);
	memset(output_buffer, 0, 264);
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	memset(input_buffer, 0, 264); // The function clears output_buffer when it fails
	if(ret == 0 && memcmp(output_buffer, input_buffer, 264) == 0) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Using bogus_data as modulus buffer size freezes (crash?) my xbox so I won't test it
	
	// 1024 key bit size but using bogus_data as key bit size freezes (crash?) my xbox so I won't test it
	memcpy(pub_key, original_magic_string, 4);
	memcpy(&pub_key[8], key_bit_size1024, 4);
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10);
	memset(output_buffer, 0, 264);
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	if(ret == 1 && validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x0c\xd6\x8f\x80\xc2\x04\xca\x68\x0b\x9d\x21\x37\x1c\xcb\x46\x32\x68\xb2\x8a\x92")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Wrong max encode size -> same result as if original value
	memcpy(&pub_key[8], original_key_bit_size, 4);
	memcpy(&pub_key[12], bogus_data, 4);
	memset(input_buffer, 0, 264);
	memcpy(input_buffer, "\x45\x6e\x63\x72\x79\x70\x74\x20\x6d\x65", 10);
	memset(output_buffer, 0, 264);
	ret = XcPKEncPublic(pub_key, input_buffer, output_buffer);
	if(ret == 1 && validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x1a\x31\x40\xee\x8e\x0b\x07\xff\x36\xe3\xb1\x8e\xc8\x87\xe2\xd7\xb1\x63\x01\xe4")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	memcpy(&pub_key[12], original_max_encode_size, 4);
	
	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcPKDecPrivate(){
	const char* func_num = "0x0156";
    const char* func_name = "XcPKDecPrivate";
    BOOL tests_passed = 1;
	ULONG ret = 0;
	UCHAR input_buffer[264]          = { 0 };
	UCHAR output_buffer[264]         = { 0 };
	UCHAR original_magic_string[]    = { 0x52,0x53,0x41,0x32 };
	UCHAR bogus_data[]               = { 0xcc,0xcc,0xcc,0xcc };
	
    print_test_header(func_num, func_name);
	
	// Correct usage
	// While this succeeds on real hardware, it still fails to give back the original "Encrypt me" string. I believe it's because the
	// prv_key is missing the parameters of the Chinese remainder theorem to perform the decryption correctly, but now I'm too lazy
	// to calculate them...
	memcpy(input_buffer, encrypted_string, sizeof(encrypted_string));
	ret = XcPKDecPrivate(prv_key, input_buffer, output_buffer);
	if(ret == 1) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Wrong magic string
	memcpy(prv_key, bogus_data, 4);
	memset(input_buffer, 0, 264);
	memcpy(input_buffer, encrypted_string, sizeof(encrypted_string));
	memset(output_buffer, 0, 264);
	ret = XcPKDecPrivate(prv_key, input_buffer, output_buffer);
	memset(input_buffer, 0, 264); // The function clears output_buffer when it fails
	if(ret == 0 && memcmp(output_buffer, input_buffer, 264) == 0) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	memcpy(prv_key, original_magic_string, 4);
	
	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcPKGetKeyLen(){
    const char* func_num = "0x0157";
    const char* func_name = "XcPKGetKeyLen";
    BOOL tests_passed = 1;
	ULONG ret = 0;
	UCHAR original_key_size[] = { 0x08,0x01,0x00,0x00 };
	UCHAR bogus_data[]        = { 0xcc,0xcc,0xcc,0xcc };

    print_test_header(func_num, func_name);
	
	// Public key
	ret = XcPKGetKeyLen(pub_key);
	if(ret == 0x108) {
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}
	
	// Wrong key lenght
	memcpy(&pub_key[4], bogus_data, 4);
	ret = XcPKGetKeyLen(pub_key);
    if(ret == 0xcccccccc) {
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}
	
	// Private key
	memcpy(&pub_key[4], original_key_size, 4);
	ret = XcPKGetKeyLen(prv_key);
	if(ret == 0x108) {
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}
	
	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcVerifyPKCS1Signature(){
	const char* func_num = "0x0158";
    const char* func_name = "XcVerifyPKCS1Signature";
    BOOL tests_passed = 1;
	ULONG ret = 0;
	UCHAR digest[]     = { 0xd2,0x98,0x3c,0x52,0x96,0x43,0x95,0x2f,0xf9,0x5b,0x9a,0xc3,0x67,0x4c,0xb4,0x3a,0xfb,0x3d,0x3d,0x69 };
    UCHAR digest_inv[] = { 0x69,0x3d,0x3d,0xfb,0x3a,0xb4,0x4c,0x67,0xc3,0x9a,0x5b,0xf9,0x2f,0x95,0x43,0x96,0x52,0x3c,0x98,0xd2 };
	UCHAR signature[]  = {
        0x9c,0x64,0x3f,0xf1,0x56,0x89,0xd7,0x26,0xbb,0xf7,0x42,0xf2,0x37,0x31,0x0f,0x23,0x77,0x91,0x5e,0x2d,0xe7,0x6d,0x56,0xcf,0x87,0x30,
        0x97,0x1f,0x82,0xc9,0xe3,0x0d,0x9e,0xd5,0x25,0xec,0xe1,0xbf,0x27,0x5c,0x04,0x3d,0xc4,0xf8,0x42,0x3c,0x76,0xaa,0x34,0xa3,0xd2,0x01,
        0x76,0xaa,0xdf,0x9a,0x32,0x33,0xb6,0xed,0x7f,0xc5,0x32,0xb4,0x1f,0x22,0x46,0x09,0x50,0xb2,0xb2,0xc7,0x0b,0xb4,0xd9,0x2c,0x08,0x7b,
        0x2a,0x62,0x5b,0x42,0xad,0x04,0xad,0xac,0xa2,0x9b,0xed,0xbb,0x6b,0xe4,0xda,0xb9,0xb7,0x12,0x7f,0xc0,0x7c,0x61,0x6c,0x89,0x21,0x9c,
        0x14,0x1a,0x66,0xcd,0x41,0x1f,0xad,0x95,0xcb,0xc5,0x3b,0x54,0x3e,0x6a,0x54,0x19,0x88,0x4d,0x5e,0x57,0x1f,0x33,0x61,0xd6,0x63,0xef,
        0xaa,0x59,0x53,0xce,0xfc,0x48,0xc1,0x6b,0x5b,0x4e,0x77,0x95,0x20,0x53,0x4a,0x0d,0x84,0xd1,0x40,0x41,0x41,0x27,0x40,0xee,0x12,0x4b,
        0x5d,0x55,0xb2,0xbf,0x47,0xce,0x88,0x8d,0xb0,0xde,0x53,0x79,0x25,0xa3,0x59,0xae,0xd8,0xca,0x63,0x9a,0x51,0x66,0x32,0xb8,0x6f,0x65,
        0xac,0xe3,0x81,0x15,0x6a,0xd8,0xa8,0xdf,0x44,0x47,0xfc,0x31,0x55,0xf9,0x92,0x27,0x85,0x7d,0x0c,0xd1,0xb6,0x25,0xcd,0x72,0xcd,0xb5,
        0x94,0xd5,0x25,0x92,0xc4,0x1d,0x23,0x03,0x58,0x28,0xc0,0xab,0x7f,0x3b,0xd0,0x40,0x4d,0x1f,0x89,0x98,0x40,0xd8,0x23,0x40,0x6d,0xdd,
        0xc7,0x61,0xbc,0x6a,0xbb,0x56,0x91,0x2e,0x47,0xd1,0x3b,0x97,0xed,0xa7,0x91,0xb7,0x87,0x70,0x30,0x6f,0xdc,0x30
	};
	
	print_test_header(func_num, func_name);
	
	ret = XcVerifyPKCS1Signature(signature, XePublicKeyData, digest);
	if(ret == 1) {
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}
	
	ret = XcVerifyPKCS1Signature(signature, XePublicKeyData, digest_inv);
	if(ret == 0) {
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}

	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcModExp(){
	const char* func_num = "0x0159";
    const char* func_name = "XcModExp";
    BOOL tests_passed = 1;
	ULONG ret = 0;
	ULONG output = 0;
	ULONG a      = 0x10;
	ULONG b      = 0x20;
	ULONG c      = 0x30;
	
    print_test_header(func_num, func_name);
	
	ret = XcModExp(&output, &a, &b, &c, 4/sizeof(ULONG));
	if(ret == 1 && output == 0x10) {
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}

	// Passing a size of zero freezes (crash?) my xbox so I won't test it
	
	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcDESKeyParity(){
    const char* func_num = "0x015a";
    const char* func_name = "XcDESKeyParity";
    BOOL tests_passed = 1;
	UCHAR key_des[8] = { 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17 };
	
	print_test_header(func_num, func_name);
	
	XcDESKeyParity(key_des, sizeof(key_des));
	if(memcmp(key_des, "\x10\x10\x13\x13\x15\x15\x16\x16", 8) == 0){
        tests_passed &= 1;
	}
    else {
        tests_passed &= 0;
	}

	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcKeyTable(){
    const char* func_num = "0x015b";
    const char* func_name = "XcKeyTable";
    BOOL tests_passed = 1;
	ULONG chiper_selector;
	UCHAR key_table_des[128]    = { 0 };
	UCHAR key_table_3des[128*3] = { 0 };
	UCHAR key_des[8]            = { 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17 };
	UCHAR key_3des[8*3]         = {
		0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
		0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37
	};
	
	print_test_header(func_num, func_name);
	
	// Des
	XcDESKeyParity(key_des, sizeof(key_des));
	chiper_selector = 0;
	XcKeyTable(chiper_selector, key_table_des, key_des);
	if(validate_hashed_result(key_table_des, sizeof(key_table_des),
	(PUCHAR)"\xf4\x45\x75\x1a\xbd\xe0\x89\x3b\xd8\x6f\x5d\x02\xf3\x87\x83\x1f\x7d\xb8\x39\xc4")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// 3des
	XcDESKeyParity(key_3des, sizeof(key_3des));
	chiper_selector = 1;
	XcKeyTable(chiper_selector, key_table_3des, key_3des);
	if(validate_hashed_result(key_table_3des, sizeof(key_table_3des),
	(PUCHAR)"\xc2\xcd\x96\x3a\x00\x63\x33\x82\xeb\x7c\x25\x78\x8e\x4e\x47\xa6\x52\x72\x1f\xec")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Bogus chiper selector value (3des)
	memset(key_table_3des, 0, sizeof(key_table_3des));
	chiper_selector = 0xffffffff;
	XcKeyTable(chiper_selector, key_table_3des, key_3des);
	if(validate_hashed_result(key_table_3des, sizeof(key_table_3des),
	(PUCHAR)"\xc2\xcd\x96\x3a\x00\x63\x33\x82\xeb\x7c\x25\x78\x8e\x4e\x47\xa6\x52\x72\x1f\xec")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcBlockCrypt(){
    const char* func_num = "0x015c";
    const char* func_name = "XcBlockCrypt";
    BOOL tests_passed = 1;
	ULONG chiper_selector;
	UCHAR input_buffer[8]       = { 0x54,0x65,0x73,0x74 }; // "Test"
	UCHAR output_buffer[8]      = { 0 };
	UCHAR key_table_des[128]    = { 0 };
	UCHAR key_table_3des[128*3] = { 0 };
	UCHAR key_des[8]            = { 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17 };
	UCHAR key_3des[8*3]         = {
		0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
		0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37
	};
	
	print_test_header(func_num, func_name);
	
	// Des - enc
	XcDESKeyParity(key_des, sizeof(key_des));
	chiper_selector = 0;
	XcKeyTable(chiper_selector, key_table_des, key_des);
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_des, 1);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x2a\x6c\x52\x95\x2c\x94\x23\xe7\x88\x30\x72\x85\xd4\xca\x40\xe4\x56\xe8\xb8\x60")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Des - dec
	memcpy(input_buffer, output_buffer, sizeof(input_buffer));
	memset(output_buffer, 0, sizeof(output_buffer));
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_des, 0);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x40\x34\x58\xa2\x26\xff\x6b\x3e\xa6\x49\xde\xc2\x34\x05\x7a\xdf\x58\x57\x38\x4a")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// Bogus operation value (des)
	memcpy(input_buffer, output_buffer, sizeof(input_buffer));
	memset(output_buffer, 0, sizeof(output_buffer));
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_des, 0xffffffff);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x2a\x6c\x52\x95\x2c\x94\x23\xe7\x88\x30\x72\x85\xd4\xca\x40\xe4\x56\xe8\xb8\x60")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// 3des - enc
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x54\x65\x73\x74", 4);
	memset(output_buffer, 0, sizeof(output_buffer));
	XcDESKeyParity(key_3des, sizeof(key_3des));
	chiper_selector = 1;
	XcKeyTable(chiper_selector, key_table_3des, key_3des);
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_3des, 1);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x39\xfd\x7a\xbf\x54\xd2\x59\x30\xbd\x76\xf1\xe3\x75\xe0\xb4\x95\xea\x49\x33\x60")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	// 3des - dec
	memcpy(input_buffer, output_buffer, sizeof(input_buffer));
	memset(output_buffer, 0, sizeof(output_buffer));
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_3des, 0);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x40\x34\x58\xa2\x26\xff\x6b\x3e\xa6\x49\xde\xc2\x34\x05\x7a\xdf\x58\x57\x38\x4a")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Bogus operation value (3des)
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x54\x65\x73\x74", 4);
	memset(output_buffer, 0, sizeof(output_buffer));
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_3des, 0xffffffff);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\xda\x5d\x18\x4f\xd1\x0f\x2e\x33\xa1\xd1\x29\xfe\x8b\x29\xc2\x7a\x48\x81\x3c\xa2")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Bogus chiper selector value (3des-enc)
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x54\x65\x73\x74", 4);
	memset(output_buffer, 0, sizeof(output_buffer));
	chiper_selector = 0xffffffff;
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_3des, 1);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x39\xfd\x7a\xbf\x54\xd2\x59\x30\xbd\x76\xf1\xe3\x75\xe0\xb4\x95\xea\x49\x33\x60")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Bogus chiper selector value (3des-dec)
	memcpy(input_buffer, output_buffer, sizeof(input_buffer));
	memset(output_buffer, 0, sizeof(output_buffer));
	XcBlockCrypt(chiper_selector, output_buffer, input_buffer, key_table_3des, 0);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x40\x34\x58\xa2\x26\xff\x6b\x3e\xa6\x49\xde\xc2\x34\x05\x7a\xdf\x58\x57\x38\x4a")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcBlockCryptCBC(){
    const char* func_num = "0x015d";
    const char* func_name = "XcBlockCryptCBC";
    BOOL tests_passed = 1;
	ULONG chiper_selector;
	UCHAR input_buffer[8*5]     = { 0x53,0x65,0x63,0x72,0x65,0x74,0x20,0x73,0x74,0x72,0x69,0x6e,0x67 }; // "Secret string"
	UCHAR output_buffer[8*5]    = { 0 };
	UCHAR iv[8]                 = { 0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc };
	UCHAR key_table_des[128]    = { 0 };
	UCHAR key_table_3des[128*3] = { 0 };
	UCHAR key_des[8]            = { 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17 };
	UCHAR key_3des[8*3]         = {
		0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
		0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37
	};
	
	print_test_header(func_num, func_name);
	
	// Des - enc
	XcDESKeyParity(key_des, sizeof(key_des));
	chiper_selector = 0;
	XcKeyTable(chiper_selector, key_table_des, key_des);
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_des, 1, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x70\xd9\x06\xb7\x88\x89\xca\x0a\x1f\x10\xa7\xcc\xc0\x5f\xf3\xfd\xa3\xd0\x9e\x79")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Des - dec
	memcpy(input_buffer, output_buffer, sizeof(input_buffer));
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_des, 0, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x8f\x11\x6d\xc7\x6a\xf3\xb1\x28\xa2\xca\x83\x0f\x1e\x1f\xe3\xc8\x4a\xe1\xe3\xce")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Des - dec plaintext
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x53\x65\x63\x72\x65\x74\x20\x73\x74\x72\x69\x6e\x67", 13);
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_des, 0, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x1f\x28\xfc\x62\x17\xc2\x46\xa5\x10\x8c\xf1\xd8\xc5\x7a\xf6\x24\x30\xf6\x48\xf5")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Bogus operation value (des) -> same as decrypting the plaintext
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x53\x65\x63\x72\x65\x74\x20\x73\x74\x72\x69\x6e\x67", 13);
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_des, 0xffffffff, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x1f\x28\xfc\x62\x17\xc2\x46\xa5\x10\x8c\xf1\xd8\xc5\x7a\xf6\x24\x30\xf6\x48\xf5")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// 3des - enc
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x53\x65\x63\x72\x65\x74\x20\x73\x74\x72\x69\x6e\x67", 13);
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcDESKeyParity(key_3des, sizeof(key_3des));
	chiper_selector = 1;
	XcKeyTable(chiper_selector, key_table_3des, key_3des);
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_3des, 1, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x31\x34\xe5\xa6\x5f\x3b\x96\xef\x0e\x76\xe7\xea\xf4\xd3\x4e\x19\xf9\xc1\x1a\x1d")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// 3des - dec
	memcpy(input_buffer, output_buffer, sizeof(input_buffer));
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_3des, 0, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x8f\x11\x6d\xc7\x6a\xf3\xb1\x28\xa2\xca\x83\x0f\x1e\x1f\xe3\xc8\x4a\xe1\xe3\xce")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// 3des - dec plaintext
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x53\x65\x63\x72\x65\x74\x20\x73\x74\x72\x69\x6e\x67", 13);
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_3des, 0, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x42\xe5\x98\xc0\x66\x93\x1e\x81\xd0\xc4\xe2\x47\x00\x7a\x0c\x1f\x6b\x7a\x16\xbb")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Bogus operation value (3des) -> same as decrypting the plaintext
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x53\x65\x63\x72\x65\x74\x20\x73\x74\x72\x69\x6e\x67", 13);
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, sizeof(input_buffer), output_buffer, input_buffer, key_table_3des, 0xffffffff, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x42\xe5\x98\xc0\x66\x93\x1e\x81\xd0\xc4\xe2\x47\x00\x7a\x0c\x1f\x6b\x7a\x16\xbb")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	// Bogus input length value (3des-enc) -> it encrypts up to des_block (length + 7) / 8
	memset(input_buffer, 0, sizeof(input_buffer));
	memcpy(input_buffer, "\x53\x65\x63\x72\x65\x74\x20\x73\x74\x72\x69\x6e\x67", 13);
	memset(output_buffer, 0, sizeof(output_buffer));
	memset(iv, 0xcc, sizeof(iv));
	XcBlockCryptCBC(chiper_selector, 11, output_buffer, input_buffer, key_table_3des, 1, iv);
	if(validate_hashed_result(output_buffer, sizeof(output_buffer),
	(PUCHAR)"\x4e\x9c\x6d\xf9\xcc\xac\xa8\xfe\x33\xba\x6a\x30\xb4\x17\x09\x0a\x9b\x3b\x82\x59")) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}

	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcCryptService(){
    const char* func_num = "0x015e";
    const char* func_name = "XcCryptService";
    BOOL tests_passed = 1;
	ULONG a;
	void* b;
	ULONG ret;
	UCHAR test_buffer[8] = { 0 };

	print_test_header(func_num, func_name);
	
	a = 0;
	b = NULL;
	ret = XcCryptService(a, b);
	if(ret == 0 && a == 0 && b == NULL) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	a = 0xffffffff;
	b = NULL;
	ret = XcCryptService(a, b);
	if(ret == 0 && a == 0xffffffff && b == NULL) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	a = 0xffffffff;
	b = test_buffer;
	ret = XcCryptService(a, b);
	if(ret == 0 && a == 0xffffffff && (memcmp(b, "\x00\x00\x00\x00\x00\x00\x00\x00", 8) == 0)) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	a = 0;
	b = test_buffer;
	ret = XcCryptService(a, b);
	if(ret == 0 && a == 0 && (memcmp(b, "\x00\x00\x00\x00\x00\x00\x00\x00", 8) == 0)) {
		tests_passed &= 1;
	}
	else {
		tests_passed &= 0;
	}
	
	print_test_footer(func_num, func_name, tests_passed);
}

void test_XcUpdateCrypto(){
    /* FIXME: This is a stub! implement this function! */
}
